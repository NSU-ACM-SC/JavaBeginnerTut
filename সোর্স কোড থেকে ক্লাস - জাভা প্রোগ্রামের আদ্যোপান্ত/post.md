ঠিক আগের  [পোস্টটাতেই](https://goo.gl/mwALDs) আমরা একটা খুব সাধারণ জাভা প্রোগ্রাম লিখেছিলাম যেটা স্ক্রীনে একটা আউটপুট দিতে পারে । কিন্তু আমাদের কিছু প্রশ্ন রয়ে গেছে। কিছু না, অনেক প্রশ্ন । 

- আমরা কি কম্পাইল করেছি নাকি ইন্টারপ্রিট ? নাকি অন্য কিছু? 
- কোড কম্পাইল / ইন্টারপ্রিট করার পরে .class এক্সটেনশনের একটা ফাইল আসে কেন ? এইটার কাজ কি ? 
- আমার জাভা সোর্স কোড কীভাবে প্রোগ্রামে রুপান্তর হয় ? 

এই পোস্টে আমরা এইসব + এইরকম আরো প্রশ্নের উত্তর খুঁজবো। একটু কঠিন কথাবার্তা । হাতের কাছে চা কফি রাইখো নাইলে হারায়া যাবা নাইলে ঘুমায়া পড়বা । :P 

## আচ্ছা JVM কি জিনিস ? এইটা কেন লাগে ? 

JVM মানে Virtual Machine, JVM মানে Virtual Machine, JVM মানে Virtual Machine এভাবে তোতাপাখির মতন না বলে একটু মাথা খাটাও যে জাভার জন্য ভার্চুয়াল মেশিন লাগে কেন আর এই ভার্চুয়াল মেশিন ই বা কি? দেখলা এইটা পুরা ইনসেপশন হয়ে গেলো । প্রশ্নের উত্তর খুজতে গিয়ে আমরা নতুন সব প্রশ্ন পাচ্ছি । 


#### ভার্চুয়াল মেশিন কিতা ? 
আগে বলি ভার্চুয়াল মেশিন কি। ভার্চুয়াল বলতে আমরা সাধারণত কি বুঝি ? যার কোন ফিজিকাল এক্সিস্টেন্স নাই কিন্তু ইফেক্ট আছে । যেমন ফেসবুক আমাদের জন্য একটা ভার্চুয়াল জিনিস। ফেসবুকে আমি আমার বন্ধু কুদ্দুস করিম রহিমের পিঠে ঠাস করে থাবড় বসায়া দিয়ে বলতে পারি না আরে দোস্ত কি খবর ? তোরে তো অনেকদিন দেখি না । কিন্তু আমি তাকে Poke করতে পারি । (ইদানিং কেউ পোক ও করে না) । অথবা তাকে নক করতে পারি । ইন এ নাটশেল , ভার্চুয়াল ইজ নট দা রিয়াল থিং , কিন্তু এইটা ইউস করে কাজ করা যায় । তাহলে ভার্চুয়াল মেশিন কি জিনিস ? তোমার কম্পিউটার যদি একটা ফিজিকাল মেশিন হয় তাহলে তার একটা ভার্চুয়াল ভার্শন আছে কি ? থাকলে সেটা কেমন? 

অনেক আগের কথা । কম্পিউটার গুলোর প্রসেসিং পাওার ছিলো বসুন্ধরা এলাকার রিকশাওয়ালা মামাদের হাতে চলে ফোনের চাইতেও কম। ইনফ্যাক্ট, তোমার সায়েন্টিফিক ক্যালকুলেটরে যে পরিমাণ প্রসেসিং পাওার সেটা দিয়ে অ্যাপলো - ১১ এর চাঁদে  আসা যাওার সব কমিউনিকেশন হ্যান্ডেল করা সম্ভব ছিলো । ফাস্ট ফরয়ার্ড ২০১৭ সাল । এখনকার AMD Ryzen সিরিজের সবচে সস্তা প্রসেসর টাও ৪ কোর ওয়ালা । একসময় কম্পিউটার বিশাল ছিলো , ১৯৭১ সালে মাইক্রপ্রসেসর(ইন্টেল ৪০০৪) আসার পরেও ছোট হয়েছিলো বটে কিন্তু যেসব জিনিস না হলে আমাদের চলে না যেমন মাল্টিটাস্কিং (মুভি ডাউনলোড দিয়ে গেম খেলতে থাকা, ব্যাকগ্রাউন্ডে মিউজিক প্লেয়ারে গান ছেড়ে রাখা ইত্যাদি) ছিলো না। আস্তে ধীরে সেগুলা এসে পড়লো । 

কিন্তু মানুষ বড়ই বজ্জাত কিসিমের প্রাণী । কম্পিউটার ছিলো বড় , তারে ছোট করে দিয়ে তারা ক্ষান্ত হয় নাই । তাদের আরো দরকার কম্পিউটার নামক নিরীহ যন্ত্রের কাছ থেকে । এজন্য রবিঠাকুর ও বলেছিলেন - দাও দাও মোরে আরো দাও .__. 

মানুষ মাল্টিটাস্কিং আনলো , কলুর বলদের মতন প্রসেসর গুলোকে খাটানো শুরু করলো । এর মাঝে আরেকদল বজ্জাত মানুষের উদ্ভব হলো । গুজব আছে তাদের বাড়ি নোয়াখালি অঞ্চলে ছিলো । তো তারা বলতে লাগলো আচ্ছা, একাধিক প্রোগ্রাম যদি একসাথে  চালানো যায় তাহলে একাধিক অপারেটিং সিস্টেম কেন না? এক কম্পিউটারে একাধিক অপারেটিং সিস্টেম চললে তো আমাদের ই লাভ, এক মেশিন(!) দিয়েই সব সেরে দিবো । 

টেকনিকালি অপারেটিং সিস্টেম একটা প্রোগ্রাম ই । যদি অন্য প্রোগ্রাম চলতে পারে অপারেটিং সিস্টেম কেন চলবে না এইটা লজিকটা কেউ ফেলে দিতে পারলো না । একই সাথে দুইটা অপারেটিং সিস্টেম কম্পিউটারে রাখা কোন ঝামেলা না । কিন্তু একই সাথে দুইটাই চলবে এইটা কেমন শোনায় না? 

মানুষ শুধু বজ্জাত না , আজব চিড়িয়াও বটে । তারা এক নতুন ধারণা নিয়ে এলো । 

- **কুদ্দুস** - ইউ শি আবুইল্লা, আই গট দিশ বেরি নাইচ আইডিয়া !  
- **আবুইল্লা** - হোয়াট আইডিয়া ইউ টকিং এবাউট ? 
- **কুদ্দুস** - হাউ অ্যাবাউট উই ডু - মেশিন ইনসাইড এ মেশিন? 
- **আবুইল্লা** - (মনে মনেঃ বুইড়ার মাথা গেসে) ইয়েশ চ্যার বেরি নাইচ 

বুইড়ার মাথা যায় নাই । বুইড়া ঠিকই ভাবসিলো আবুল মিয়া । হোয়াটেভার । উনারা একটা প্রোগ্রাম স্ট্রাকচার বানালেন । যেটা আদতে একটা প্রোগ্রাম কিন্তু রান হলে একটা আলাদা কম্পিউটারের মতন আচরণ করে । তার নিজের র‍্যাম থাকে , সিপিউ থাকে , অপারেটিং সিস্টেম থাকে। এইটাই আসলে ভার্চুয়াল মেশিন । কিন্তু প্রোগ্রাম কীভাবে হার্ডওয়ের কে এভাবে ইউস করতে পারে ? মানে আমার তো আগেই একটা অপারেটিং সিস্টেম আছে! 

একটা ভার্চুয়াল মেশিন যা করে , সে পরজীবীর মতন তোমার আসল অপারেটিং সিস্টেমের ভেতরে ইন্সটল হয় । তুমি তাকে নিজের কম্পিউটারের র‍্যাম, সিপিউ এগুলোর শেয়ার দিতে পারো । যতটুকু দরকার ততটুকু দিতে পারো । এতে সুবিধা হচ্ছে যে আরেকটা কম্পিউটার না কিনেই তুমি নিজের উইন্ডোজ কম্পিউটারে একটা লিনাক্স মেশিন অনায়াসে চালাতে পারো । এবং সবচাইতে ভালো ব্যাপার হচ্ছে কোন কারণে তোমার ভার্চুয়াল মেশিনের কলেরা(আনে গেঞ্জাম)  হলেও মূল অপারেটিং সিস্টেমের কোন ক্ষতি হবে না । উইন উইন ফর এভ্রিবডি । যদি ভার্চুয়াল মেশিনে কোন অপারেটিং সিস্টেম ট্রাই করে দেখতে চাও , Oracle Virtual Box ফ্রীতে ডাউনলোড করা যায় , এইটাতে লিনাক্স ইন্সটল করে ট্রায়াল দিতে পারো । তবে ভার্চুয়াল মেশিন চালানোর এই প্রসেস যেটাকে ভার্চুয়ালাইজেশন বলে এর জন্য অনেক র‍্যাম থাকলে ভালো। র‍্যাম ৪ গিগা হলে স্পীড কম পাবা । ৮ গিগা হলে সুন্দর চলবে । আরেকটা জিনিস হচ্ছে এইটা মানুষ কে ধার দিতে পারবে । মানে তোমার বানানো ভার্চুয়াল মেশিনটা একটা ফাইল হিসাবে সেভ হয় । এইটা কাউকে যদি দাও সে কপি পেস্ট করে তার কম্পিউটারে অনায়াসে চালিয়ে দিতে পারবে । 

#### সব ই বুঝলাম কিন্তু জাভার ভার্চুয়াল মেশিন কেন লাগে ? 
এই প্রশ্নের উত্তর দিতে গেলে আমাদের সি ল্যাঙ্গুয়েজের কাছে যেতে হবে ।  সি তে কোড লেখার পরে যখন আমরা কম্পাইলারের কাছে সেটাকে পাঠাই কি হয়? 

- প্রথমে সি ফাইলটা কে কম্পাইলার কম্পাইল করে । 
- এরপর সে একটা ফাইল বানায়্ যার নাম অবজেক্ট ফাইল । 
- অবজেক্ট ফাইলে থাকা ইন্সট্রাকশন অনুযায়ী আমাদের প্রোগ্রামের এক্সিকিউটেবল কাজ করে । 

একটা ছবি দিলে ভালো বুঝবে । 
![Imgur](https://i.imgur.com/6oSxANO.png)

আচ্ছা এই অবজেক্ট ফাইলতার কাজ কি ? আমরা জানি কম্পিউটার ০ আর ১ ছাড়া কিছু চিনে না । আর সি কোড লেখি ইংরেজিতে । সেইটা বুঝার প্রশ্নই আসে না। সরাসরি বাইনারি তে কোড লিখে মাথার চান্দি হাওা করার খায়েশ কারই ছিলো না। সলুশন ছিলো , সি কোড কে অ্যাসেম্বলি তে কনভার্ট করা , এরপর সেটাকে রান করানো । অ্যাসেম্বলি কোডটাই হচ্ছে অবজেক্ট ফাইল। 

এখন কথা হচ্ছে অ্যাসেম্বলি হলে সমস্যা কই? কিংবা দরকার কি? উপরের ছবিটা দেখো । একটা সি ফাইলের জন্য ৩ অপারেটিং সিস্টেমে কেন ৩ টা প্রোগ্রাম হচ্ছে ? এর একটা বড় কারণ হচ্ছে সি এর কম্পাইলার যে অবজেক্ট ফাইল টা বানায় সেটা অপারেটিং সিস্টেম ডিপেন্ডেন্ট । এক অপারেটিং সিস্টেম এরটা আরেক অপারেটিং সিস্টেম এ চলে না । নতুন করে কম্পাইল করা লাগে । ১৯৭০ সালে এত ঝামেলা ছিলো না । ঝামেলা বাড়লো যখন সি++ এলো আর মানুষ হাই ফাই সফটওয়্যার লেখা শুরু করলো । সি++ ছিলো সি এর স্পিরিচুয়াল ছোট ভাই । সি এর সব সিস্টেম রপ্ত করেই সে এসেছিলো । যেকারণে সি++ এর কম্পাইলার বা লাইব্রেরী সি এর জন্য ও ইউস করা যায় । কিন্তু সি++ এর সমস্যা কি ছিলো যে ১৯৯৭ সালের দিকে এসে জাভাকে জন্ম নিতে হলো তার উপর ভার্চুয়াল মেশিন ইউস করতে হলো?    

সি++ এর অনেক সমস্যা ছিলো কিন্তু আসলটা ছিলো হচ্ছে পোর্টেবিলিটি । অবজেক্ট ফাইল অপারেটিং সিস্টেম ডিপেন্ডেন্ট হওাতে প্রতি অপারেটিং সিস্টেমের জন্য বারবার কোড কম্পাইল করা লাগতো । আমাদের সাধারণ কাজের ২-৩ টা সোর্স ফাইল কম্পাইল করা এত ঝামেলার কাজ না । কিন্তু বড় বড় সফটওয়্যার এর প্রোজেক্টে হাজার হাজার ফাইল থাকে । সেগুলো বারবার কম্পাইল করতে অনেক সময় লাগতো । 

জাভার নির্মাতারা যে এপ্রোচে গেলেন যে , বাপু অবজেক্ট কোড তো লাগবেই । নাহলে মেশিন কে খাওাবো কি, মেশিন মহেষ নামক গরু না হতে পারে, কিন্তু তাকে কিছু দিতে তো হবে কাজ করতে! যেহেতু অবজেক্ট ফাইলটা প্ল্যাটফর্ম ডিপেন্ডেন্ট , সেই প্ল্যাটফর্ম টা একটা ভার্চুয়াল মেশিন হলে কেমন হয় ? ভার্চুয়াল মেশিন সবাইকে দিয়ে বেড়াবো , সবার জন্য একই অবজেক্ট কোড থাকবে । তাতে সুবিধা হবে একই কোড বারবার কম্পাইল করা লাগবে না । একবার কেউ কম্পাইল করলেই চলবে । জাভার এই এপ্রোচ একটা রেভুলেশন ছিলো । এইটা না আসলে আজকের ইন্টারনেটের এত সার্ভিস আর এন্ড্রয়েড অপারেটিং সিস্টেম আলোর মুখ দেখতো না । ইমেজিন তুমি এন্ড্রয়েড অ্যাপ বানিয়েছো সেটাকে এখন তোমারে সব ব্র্যান্ডের প্রতি মডেলের জন্য কম্পাইল করতে হবে । আমাকে এই কাজ করতে বললে আচ্ছা চলি বাই বলে এসে পড়তাম । 

এখন জাভা নতুন ল্যাঙ্গুয়েজ, তার এত সুন্দর কনসেপ্টে আদি আমলের নাম থাকলে কি চলে? তাই তারা অবজেক্ট কোডের যে ভার্শনের কথা ভেবেছিলেন সেটার নাম দিলেন বাইটকোড । আরেকটা ছবি দেই । 

![Imgur](https://i.imgur.com/Gi4lZY7.jpg)

তুমি জাভা কোড লিখে কম্পাইল করবা , বাইটকোড জেনারেট হবে । সে বাইটকোড মানুষ রে দিয়ে বেড়াবা । তারা যখন রান করবে JVM সেটা নিজে রান করে নিবে । ইজি , সিম্পল । 

## কম্পাইল করলাম নাকি ইন্টারপ্রিট -  জাতি  জবাব চায় । 

জাভা কম্পাইল হয় । কিন্তু কম্পাইলেশনের পরে সে বাইটকোড বানায় । বাইটকোড যখন JVM এ যায় তখন সে ইন্টারপ্রিট হয় । 

## .class এক্সটেনশনের ফাইল কি তাহলে বাইটকোডের ফাইল? 

ইয়েচ শ্যার। এইটাই বাইট কোড । কিন্তু এইটা আমরা দেখবো ক্যামনে? ট্রাস্ট মি , কম্পিউটার আর্কিটেকচার / মাইক্রোপ্রসেসর কোর্সের অ্যাসেম্বলি কোড দেখার আগে এই জিনিস না দেখাই উত্তম বাট ইফ ইউ স্টিল ইন্সসিস্ট! 

#### বাইটকোড পড়া 
ধরা যা আমার বাইটকোড ফাইলের নাম HelloJava.class 

তাহলে কমান্ড লাইনে লেখা লাগবে - 
 ```bash
 javap -v HelloJava.class
 ```  

কমান্ড লাইনে একেবারে সব দেখিয়ে দিবে ।
```java
Classfile /Users/shawon/Desktop/HelloJava.class
  Last modified Sep 27, 2017; size 422 bytes
  MD5 checksum 0a5756ec490464ddc9e3982700f5e9bc
  Compiled from "HelloJava.java"
public class HelloJava
  minor version: 0
  major version: 53
  flags: (0x0021) ACC_PUBLIC, ACC_SUPER
  this_class: #5                          // HelloJava
  super_class: #6                         // java/lang/Object
  interfaces: 0, fields: 0, methods: 2, attributes: 1
Constant pool:
   #1 = Methodref          #6.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #18            // Hello Java
   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #21            // HelloJava
   #6 = Class              #22            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               SourceFile
  #14 = Utf8               HelloJava.java
  #15 = NameAndType        #7:#8          // "<init>":()V
  #16 = Class              #23            // java/lang/System
  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;
  #18 = Utf8               Hello Java
  #19 = Class              #26            // java/io/PrintStream
  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V
  #21 = Utf8               HelloJava
  #22 = Utf8               java/lang/Object
  #23 = Utf8               java/lang/System
  #24 = Utf8               out
  #25 = Utf8               Ljava/io/PrintStream;
  #26 = Utf8               java/io/PrintStream
  #27 = Utf8               println
  #28 = Utf8               (Ljava/lang/String;)V
{
  public HelloJava();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String Hello Java
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 5: 0
        line 7: 8
}
SourceFile: "HelloJava.java"

```

#### বাইটকোড থেকে কি কোড ফেরত পাওা যায় ? 
ধরো কেউ তোমাকে ক্লাস ফাইল দিলো । মানে বাইটকোড ফাইল দিলো । তুমি বেশ কৌতূহলি মানুষ তুমি জানতে চাও ভেতরে কি কোড লেখা আছে । তোমার জন্য কমান্ড লাইনের একটা কমান্ড দিয়েই কাজ হয়ে যাবে । 

```bash
javap -p HelloJava.class
```
আউটপুট দেখাবে এমন - 
```java
Compiled from "HelloJava.java"
public class HelloJava {
  public HelloJava();
  public static void main(java.lang.String[]);
}
```

আপাতত কোডের অনেক কিছু নাও বুঝতে পারো , বাইটকোডের কিছুই নাও বুঝতে পারো , আমি নিজেও বুঝি না বাইটকোডে কি আছে । অ্যাসেম্বলি একেক জায়গায়া একেক রকম । ওগুলো মারফতি জিনিস। ওগুলোর পেছনে না দৌড়াই! 

## সোর্স কোড কীভাবে প্রোগ্রামে যায় 
এতক্ষনে ধরে ফেলার কথা ! কোড -> বাইটকোড -> প্রোগ্রাম । 

## আচ্ছা তাহলে JDK, JRE এর কাজ কি ?

সহজ ভাষায় বলতে গেলে - 
- JDK বাইটকোড টা জেনারেট করে। 
- JRE বাইটকোড রিড করে , JVM রেডি করে , JVM এ বাইটকোড ইনপুট দেয় , মোদ্দাকথা তোমার জাভা প্রোগ্রাম রান করায় । 

## জাভা প্রোগ্রাম যেহেতু JVM এ রান হয়, তাহলে আমি যদি একাধিক প্রোগ্রাম রাখি , তার জন্য কয়টা JVM হয় ? 

সহজ উত্তর - যে কয়টা প্রোগ্রাম সে কয়টা জেভিএম রান হবে। এখন প্রশ্ন আসতে পারে তাহলে তো আমার কম্পিউটার স্লো হয়ে যাবে , এতগুলো ভার্চুয়াল মেশিন! ওয়েল অনেকগুলো একসাথে চললে স্লো হতে পারে । ইনেভিটেবল । কিন্তু JRE এই জিনিসটা ভালো করেই ম্যানেজ করে । আর JVM এমনভাবেই ডিজাইন করা হয়েছে যাতে সেটা কম্পিউটারের মূল অপারেটিং সিস্টেমের কোন কাজে ব্যাঘ্যাত ঘটাতে না পারে । এদিক দিয়ে অনেক অপ্টিমাইজড এবং সিকিউর । 

## ভাই ঘুম পাইসে । 
 (লম্বা হাই) ভাই আমারো ঘুম পাইসে । এই লাইনটা লেখার সময় ঘড়িতে রাত ২ টা ৫০ বাজে। ঘুমাইতে গেলাম । ইয়া বড় পোস্টে লিখে ফেলসি । অনেক কঠিন কথা বলে ফেলসি । পরিবেশ ভারী গুমোট । একটু হালকা করা দরকার যাতে ঘুমাইতে পারো । 

 নিচে কিছু লিংক দিলাম । দেখে আসতে পারো। ;) 

#### নন আঁতেল বা অনাঁতেল লোকদের জন্য -
- [https://youtu.be/3vI_7os2V_o](https://youtu.be/3vI_7os2V_o)
- [https://youtu.be/8Px-GHPxB4I](https://youtu.be/8Px-GHPxB4I) এইটা মাইক্রোসফটের ফ্যানদের না দেখাই উত্তম , কিন্তু একটা কঠিন সত্য ঘটনা দেখাইসে । 
- [https://youtu.be/DGa6MAibjzA](https://youtu.be/DGa6MAibjzA)
- [https://youtu.be/HXvm76e2X1Q](https://youtu.be/HXvm76e2X1Q)
- [https://youtu.be/1JZnj4eNHXE](https://youtu.be/1JZnj4eNHXE)

#### আঁতেল এবং লাইফলেস দের জন্য 
- [Is Java a Compiled or an Interpreted programming language ?](https://stackoverflow.com/questions/1326071/is-java-a-compiled-or-an-interpreted-programming-language)
- [Understanding JVM Internals, from Basic Structure to Java SE 7 Features](https://dzone.com/articles/understanding-jvm-internals)
